##dict1 = {"PERSON": ["Mr White", "Mr. White", "White", "John Worsfold", "Laurence White", "John", "Mr Trajan John Kukulovski", "John Kukulovski", "Trajan John Kukulovski", "Trajan Kukulovski"], "ORG": []}
dict1 = {"PERSON": {"Laurence White":[(1,2,3,4)], "Mr Laurence Fredric White":[(8,9,9104)], "Laurence White":[(8,9,9,104)], "Mr White":[("ab",5,6,"zw"), (9,10,"f","h")], "WHITE":[("ab",5,6,"zw"), (9,10,"f","h")], "Mr Laurence White":[("ab",5,6,"zw"), (9,10,"f","h")], "Laurence Fredric White":[("ab",5,6,"zw"), (9,10,"f","h")]}, "ORG": {"1":1}}
##dict1 = {"PERSON": {"Laurence White":[(1,2,3,4)], "Mr Laurence Fredric White":[(8,9,9104)], "Laurence White":[(8,9,9,104)], "Mr White":[("ab",5,6,"zw"), (9,10,"f","h")], "WHITE":[("ab",5,6,"zw"), (9,10,"f","h")], "Mr Laurence White":[("ab",5,6,"zw"), (9,10,"f","h")], "Laurence Fredric White":[("ab",5,6,"zw"), (9,10,"f","h")]}, "ORG": {"1":1}}
##dict1 = {'PERSON': {'Laurence White': [('0000 names.pdf', 1, 1, 'Laurence White is the best \n')], 'John Titterton': [('0000 names.pdf', 1, 3, 'John Titterton is not the best \n')], 'John': [('0000 names.pdf', 1, 4, 'John is not the best \n')], 'Titterton': [('0000 names.pdf', 1, 5, 'Mr Titterton is not the best. \n \n')]}, 'WORD': {'the': [('0000 names.pdf', 1, 1, 'Laurence White is the best \n'), ('0000 names.pdf', 1, 2, 'Mr White is the best \n'), ('0000 names.pdf', 1, 3, 'John Titterton is not the best \n'), ('0000 names.pdf', 1, 4, 'John is not the best \n'), ('0000 names.pdf', 1, 5, 'Mr Titterton is not the best. \n \n')], 'Laurence': [('0000 names.pdf', 1, 1, 'Laurence White is the best \n')] }
##dict1 = {'PERSON': {'Laurence White': {'Laurence White': [('0000 names.pdf', 1, 1, 'Laurence White is the best \n'), ('0000 names.pdf', 1, 2, 'Laurence White')], 'Mr White': [('0000 names.pdf', 1, 9, 'Mr White is the best \n')]}, 'Mmm': {'Mmm': [('0000 names.pdf', 1, 4, 'Mmm is hello \n'), ('0000 names.pdf', 1, 5, 'Mmm-hmm is hello \n')]}, 'John Titterton': {'John Titterton': [('0000 names.pdf', 1, 10, 'John Titterton is not the best \n')], 'John': [('0000 names.pdf', 1, 11, 'John is not the best \n')], 'Titterton': [('0000 names.pdf', 1, 12, 'Mr Titterton is not the best. \n \n')]}}, 'WORD': {'the': [('0000 names.pdf', 1, 1, 'Laurence White is the best \n'), ('0000 names.pdf', 1, 9, 'Mr White is the best \n'), ('0000 names.pdf', 1, 10, 'John Titterton is not the best \n'), ('0000 names.pdf', 1, 11, 'John is not the best \n'), ('0000 names.pdf', 1, 12, 'Mr Titterton is not the best. \n \n')], 'best': [('0000 names.pdf', 1, 1, 'Laurence White is the best \n'), ('0000 names.pdf', 1, 9, 'Mr White is the best \n'), ('0000 names.pdf', 1, 10, 'John Titterton is not the best \n'), ('0000 names.pdf', 1, 11, 'John is not the best \n'), ('0000 names.pdf', 1, 12, 'Mr Titterton is not the best. \n \n')], 'Laurence': [('0000 names.pdf', 1, 1, 'Laurence White is the best \n'), ('0000 names.pdf', 1, 2, 'Laurence White')], 'White': [('0000 names.pdf', 1, 1, 'Laurence White is the best \n'), ('0000 names.pdf', 1, 9, 'Mr White is the best \n')], 'is': [('0000 names.pdf', 1, 1, 'Laurence White is the best \n'), ('0000 names.pdf', 1, 4, 'Mmm is hello \n'), ('0000 names.pdf', 1, 5, 'Mmm-hmm is hello \n'), ('0000 names.pdf', 1, 9, 'Mr White is the best \n'), ('0000 names.pdf', 1, 10, 'John Titterton is not the best \n'), ('0000 names.pdf', 1, 11, 'John is not the best \n'), ('0000 names.pdf', 1, 12, 'Mr Titterton is not the best. \n \n')], 'trousers': [('0000 names.pdf', 1, 3, '’s trousers \n')], 's': [('0000 names.pdf', 1, 3, '’s trousers \n')], 'hello': [('0000 names.pdf', 1, 4, 'Mmm is hello \n'), ('0000 names.pdf', 1, 5, 'Mmm-hmm is hello \n'), ('0000 names.pdf', 1, 8, 'hello \n')], 'Mmm': [('0000 names.pdf', 1, 4, 'Mmm is hello \n'), ('0000 names.pdf', 1, 5, 'Mmm-hmm is hello \n')], 'hmm': [('0000 names.pdf', 1, 5, 'Mmm-hmm is hello \n')], 'Mr': [('0000 names.pdf', 1, 9, 'Mr White is the best \n'), ('0000 names.pdf', 1, 12, 'Mr Titterton is not the best. \n \n')], 'not': [('0000 names.pdf', 1, 10, 'John Titterton is not the best \n'), ('0000 names.pdf', 1, 11, 'John is not the best \n'), ('0000 names.pdf', 1, 12, 'Mr Titterton is not the best. \n \n')], 'Titterton': [('0000 names.pdf', 1, 10, 'John Titterton is not the best \n'), ('0000 names.pdf', 1, 12, 'Mr Titterton is not the best. \n \n')], 'John': [('0000 names.pdf', 1, 10, 'John Titterton is not the best \n'), ('0000 names.pdf', 1, 11, 'John is not the best \n')]}}
##dict1 = {"PERSON": ["John", "Mr Trajan John Kukulovski", "John Kukulovski", "Trajan John Kukulovski", "Trajan Kukulovski"], "ORG": []}
## Target output: {"PERSON": {"Mr Laurence White":["Mr White", "White", "Laurence White"], "Mr Trajan John Kukulovski": ["Mr Trajan John Kukulovski", "Trajan John Kukulovski", "John", "John Kukulovski", "Trajan Kukulovski"], \
##} n.b. flat not recursive filing and index also in the list.
## TO-DO
## bubble up titulars from lower reaches to "model" full names (even if never mentioned) 
## would need more smarts if to avoid inappropriate over-identification eg of John with both John Smith and John Worsfold and Ms Smith with Ms John Smith.
##Possible solution -  include them under both with possibly term warning flag.
##from pprint import pprint 
debug = False

def inn(str1, str2, debug):
    if str1 == "" or str2 == "": return False
    titulars = ("Mr", "Ms", "Mrs", "Dr", "Prof", "Member", "Judge", "President", "Chair", "Chairman", "Chairperson", "Deputy", "Acting", "Speaker") #Need to extend list significantly
    entityTags = ("Pty Ltd", "Ltd", "Limited", "Proprietary Limited", "Pte Ltd", "Private Limited", "plc", "PLC", "Company", "Co.", "Group", "Inc.", "LLC", "LLP", "SARL", "S.A.", "GmbH")
    str1IsTitular = False
    str2IsTitular = False


    str1list=str1.split()
    str2list=str2.split()
    if debug:
        print("str1:",str1,"str2",str2)
        print("str1list:",str1list)
        print("str2list",str2list)
    if any((str1list[0].strip(".").casefold() == i.casefold()) for i in titulars):
        str1IsTitular = True
        str1list=str1list[1:]
        str1short=(" ".join(str1list))
##        if debug: print("str1IsTitular true")
    if any((str2list[0].strip(".").casefold() == i.casefold()) for i in titulars):
        str2IsTitular = True
        str2list=str2list[1:]
        str2short=(" ".join(str2list))
    if str1IsTitular:
        if str2IsTitular:
            return inn(str1short,str2short, False)
        else:
            return inn (str1short, str2, False)
    else:
        if str1.casefold() in str2.casefold() and str1.casefold() != str2.casefold() :
##            if debug: print("Test1 true")
            return True
    ##        The following code not working correctly - designed to handle titular cases.

        elif all((item.casefold() in str2.casefold() and item.casefold() != str2.casefold() and str1.casefold() != str2.casefold()) for item in str1list):
##            if debug: print("Test2 true")
            return True
        else:
##            if debug: print("False")
            return False

def arrangeAliases(dict1, debug):

    for key in dict1:
        if key == "PERSON" or key == "ORG":
            oldPersonDict = dict1[key]
            newPersonDict = {}

## For each expression in the list of persons, if it is not contained in any other expression, create term dictionary item for it.
## The dictionary value will be term dictionary of all the items that are 'contained' in it in the broader sense. For each item, the list of tuples that menton that item will be the values.
            lst = list(oldPersonDict.items())
            if debug: print("lst: ",lst)
            for i in range(len(lst)):

                        term = lst[i][0]
                        if all(not inn(term,lst[j][0], False) for j in range(len(lst))):
##                        if debug: print("newPersonDict[lst[i][0]]:",newPersonDict[lst[i][0]])
                            newPersonDict[term] = {}
## create an entry for self
                            newPersonDict[term][term] = lst[i][1]
                                                    
# if it is already contained in another item then combine the entries by inserting the item and its list of tuples as term new entry in the dictionary.
## TODO - only if the biggest string that contains it!

            for i in range(len(lst)):
                term = lst[i][0]
                if term in newPersonDict:
                    for j in range(len(lst)):
                        term2 = lst[j][0]
                        if inn(term2,term, False):
                            newPersonDict[term][term2] = lst[j][1]
                            if debug: print("newPersonDict:",newPersonDict)
            dict1[key] = newPersonDict
            if debug: print("newPersonDict:",newPersonDict)
##    if debug: print("output",dict1)
    return(dict1)

if __name__ == "__main__":
    
    if debug:
        print("input:")
        pprint(dict1)
    newDict = arrangeAliases(dict1, debug)
    if debug:
        print("output:")
        pprint(newDict)
